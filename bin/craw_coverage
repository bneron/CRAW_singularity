#! /usr/bin/env python3

##########################################################################
#
# This file is part of Counter RNAseq Window (craw) package.
#
#    craw is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    craw is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with craw.  If not, see <http://www.gnu.org/licenses/>.
#
############################################################################

import os
import sys
import argparse
import itertools

import pysam

if 'CRAW_HOME' in os.environ and os.environ['CRAW_HOME']:
    if os.environ['CRAW_HOME'] not in sys.path:
        sys.path.insert(0, os.environ['CRAW_HOME'])
try:
    import craw
except ImportError as err:
    msg = "Cannot import craw, check your installation or your CRAW_HOME variable : {0!s}".format(err)
    sys.exit(msg)
from craw import annotation, coverage

def positive_int(value):
    """
    Parse value given by the parser

    :param value: the value given by the parser
    :type value: string
    :return: the integer corresponding to the value
    :rtype: int
    :raise:  :class:`argparse.ArgumentTypeError`
    """
    try:
        value = int(value)
    except ValueError:
        raise argparse.ArgumentTypeError("must be a positive integer, got: {}".format(value))
    if value < 0:
        msg = "must be a positive integer, got: {}".format(value)
        raise argparse.ArgumentTypeError(msg)
    return value


def quality_checker(value):
    """
    Parse value given by the parser

    :param value: the value given by the parser
    :type value:  string
    :return: the integer >=0 and <=42 corresponding to the value
    :rtype: int
    :raise:  :class:`argparse.ArgumentTypeError` if value does not represent a integer >=0 and <=42
    """

    try:
        value = int(value)
    except ValueError:
        raise argparse.ArgumentTypeError("must be a integer between 0 and 42, got: {}".format(value))
    if not 0 <= value <= 42:
        raise argparse.ArgumentTypeError("must be a integer between 0 and 42, got: {}".format(value))
    return value


def get_result_header(annot_parser, cmdline_args):
    """

    :param annot_parser:
    :param cmdline_args:
    :return:
    """
    header = "# Running Counter RnAseq Window craw_coverage\n"
    header += "# Version: {}\n".format(craw.get_version_message())
    header += "# With the following arguments:\n"
    for a, v in sorted(cmdline_args.__dict__.items()):
        if v is not None:
            header += "# --{opt}={val}\n".format(opt=a.replace('_', '-'), val=v)

    header = header.rstrip() + '\n'

    metadata = '\t'.join([str(f) for f in annot_parser.header])
    if cmdline_args.start_col:
        max_left, max_right = annot_parser.max()
        pos = '\t'.join(str(p) for p in range(0 - max_left, max_right + 1))
    else:
        pos = '\t'.join(str(p) for p in range(0 - cmdline_args.before, cmdline_args.after + 1))
    header += "sense\t{metadata}\t{pos}".format(metadata=metadata, pos=pos)
    return header


def get_results_file(sense_opt, basename, suffix):
    if sense_opt == 'S':
        sense_filename = "{filename}.sense.{suffix}".format(filename=basename, suffix=suffix)
        sense = open(sense_filename, 'w')
        antisense = open(os.devnull, 'w')
    elif sense_opt == 'AS':
        sense = open(os.devnull, 'w')
        antisense_filename = "{filename}.antisense.{suffix}".format(filename=basename, suffix=suffix)
        antisense = open(antisense_filename, 'w')
    elif sense_opt == 'split':
        sense_filename = "{filename}.sense.{suffix}".format(filename=basename, suffix=suffix)
        sense = open(sense_filename, 'w')
        antisense_filename = "{filename}.antisense.{suffix}".format(filename=basename, suffix=suffix)
        antisense = open(antisense_filename, 'w')
    else:
        output_filename = "{filename}.{suffix}".format(filename=basename, suffix=suffix)
        sense = open(output_filename, 'w')
        antisense = sense
    return sense, antisense


parser = argparse.ArgumentParser()
parser.add_argument("-b", "--bam",
                    required=True,
                    help="The path of the bam file to analyse")
parser.add_argument("-a", "--annot",
                    required=True,
                    help="The path of the annotation file.")
parser.add_argument("-q", "--qual-thr",
                    dest='qual_thr',
                    type=quality_checker,
                    default=15,
                    help="The minimal quality of read mapping to take it in account")
parser.add_argument("-s", "--suffix",
                    default="cov",
                    help="The name of the suffix to use for the output file.")
parser.add_argument('-o', '--output',
                    dest='output',
                    help="The path of the output (default= base name of annotation file with --suffix)")
region_grp = parser.add_argument_group(title="region of interest",
                                       description="""Parameters which define regions to compute
There is 2 way to define regions:
    - all regions have same length
    - each region have different lengths
in both case  a position of reference must be define (--ref-col default = position)
if all regions have same length:
    --window define the number of nucleotide to take in account before and after the reference position
      (the window will be centered on reference)
    --before define the number of nucleotide to take in account before the reference position.
    --after define the number of nucleotide to take in account after the reference position.
    --before and --after allow to define non centered window.
--after and --before options must be set together and are incompatible with --window option.

If all regions have different lengths. The regions must be specified in the annotation file.
    --start-col define the name of the column in annotation file which define the start position of the region to compute.
    --stop-col define the name of the column in annotation file which define the stop position of the region to compute.
""")
region_grp.add_argument("--ref-col",
                        default="position",
                        help="The name of the column for the reference position.")
region_grp.add_argument("--before",
                        type=positive_int,
                        help="The number of base to compute after the position of reference.")
region_grp.add_argument("--after",
                        type=positive_int,
                        help="The number of base to compute before the position of reference.")
region_grp.add_argument("--window",
                        type=positive_int,
                        help="The number of base to compute around the position of reference.")
region_grp.add_argument("--start-col",
                        help="The name of the column to define the start position.")
region_grp.add_argument("--stop-col",
                        help="The name of the column to define the stop position.")

parser.add_argument("--sense",
                    choices=('S', 'AS', 'split', 'mixed'),
                    default='mixed',
                    help="compute result only on: "
                         "sense (S), "
                         "antisense (AS), "
                         "on both senses but produce two separated files (split), "
                         "or in one file (mixed)."
                    )

parser.add_argument("--version",
                    action='version',
                    version=craw.get_version_message())
args = parser.parse_args()

group_one = (args.before, args.after, args.window)
group_two = (args.start_col, args.stop_col)
if all([v is None for v in itertools.chain(group_one, group_two)]):
    raise argparse.ArgumentError(None, "[--window or [--before, --after] or [--start-col, --stop-col] options"
                                 " must be specified")
elif any([v is not None for v in group_one]) and any([v is not None for v in group_two]):
    raise argparse.ArgumentError(None, "Options [--before, --after, --window] and [--start-col, --stop-col] "
                                 "are mutually exclusives.")
elif all([v is None for v in group_two]):
    if args.window is None:
        if any([v is None for v in (args.before, args.after)]):
            raise argparse.ArgumentError(None, "The two options --after and --before work together."
                                         " The both options must be specified in same time")
        else:
            pass
            # window is None, before and after are specify
            # => nothing to do
    else:
        # args.window is not None:
        if any([v is not None for v in (args.before, args.after)]):
            raise argparse.ArgumentError(None, "options [--before, --after] and --window are mutually exclusives.")
        else:
            # --before, --after are None
            args.before = args.after = args.window
elif not all(group_two):
    raise argparse.ArgumentError(None, "The two options --start-col and --stop-col work together. "
                                 "The both options must be specified in same time")


annot_parser = annotation.AnnotationParser(args.annot, args.ref_col,
                                           strand_col='strand',
                                           start_col=args.start_col, stop_col=args.stop_col)

sam_file = pysam.AlignmentFile(args.bam, "rb")
annotations = annot_parser.get_annotations()

if not args.output:
    args.output = os.path.splitext(args.bam)[0]
    out_name = args.output
else:
    out_name, suffix = os.path.splitext(args.output)
    suffix = suffix.strip('.')
    if not suffix:
        suffix = args.suffix

sense_file, antisense_file = get_results_file(args.sense, out_name, suffix)

with sense_file, antisense_file:
    header = get_result_header(annot_parser, args)
    max_left, max_right = annot_parser.max()
    if args.sense in ('S', 'split', 'mixed'):
        print(header, file=sense_file)
    if args.sense in ('AS', 'split'):
        print(header, file=antisense_file)
    for annot_num, annot_entry in enumerate(annotations, 1):
        if annot_num % 50 == 0:
            print('.', end='', file=sys.stderr)
            if annot_num % 2500 == 0:
                print('', file=sys.stderr)
            sys.stderr.flush()
        if args.start_col:
            start = annot_entry.start - 1
            stop = annot_entry.stop
        else:
            start = annot_entry.ref - args.before - 1
            stop = annot_entry.ref + args.after
        forward_cov, reverse_cov = coverage.get_coverage(sam_file,
                                                         annot_entry,
                                                         start=start, stop=stop,
                                                         qual_thr=args.qual_thr,
                                                         max_left=max_left, max_right=max_right)
        sens = 'S' if annot_entry.strand == '+' else 'AS'
        if sens == 'S':
            print(sens, annot_entry, *forward_cov, sep='\t', file=sense_file)
        else:
            print(sens, annot_entry, *forward_cov, sep='\t', file=antisense_file)

        sens = 'S' if annot_entry.strand == '-' else 'AS'
        if sens == 'S':
            print(sens, annot_entry, *reverse_cov, sep='\t', file=sense_file)
        else:
            print(sens, annot_entry, *reverse_cov, sep='\t', file=antisense_file)

print(file=sys.stderr)
