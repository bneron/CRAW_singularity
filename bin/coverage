#! /usr/bin/env python3

import os
import sys
import argparse
import itertools

import pysam

if 'CRAW_HOME' in os.environ and os.environ['CRAW_HOME']:
    if os.environ['CRAW_HOME'] not in sys.path:
        sys.path.insert(0, os.environ['CRAW_HOME'])
try:
    from craw import annotation
except ImportError as err:
    msg = "Cannot import craw, check your installation or your CRAW_HOME variable : {0!s}".format(err)
    sys.exit(msg)

from craw import coverage


def positive_int(string):
    value = int(string)
    if value < 0:
        msg = "must be a positive integer, got: {}".format(string)
        raise argparse.ArgumentTypeError(msg)
    return value


def quality_checker(string):
    value = int(string)
    if not 0 <= value <= 42:
        msg = "must be a integer between 0 and 42, got: {}".format(string)
        raise argparse.ArgumentTypeError(msg)
    return value


parser = argparse.ArgumentParser()
parser.add_argument("--bam",
                    required=True,
                    dest='bam_file',
                    help="the path of the bam file to analyse")
parser.add_argument("--annot",
                    required=True,
                    dest='annot_file',
                    help="the path of the annotation file.")
parser.add_argument("--quality-threshold",
                    dest='qual_thr',
                    type=quality_checker,
                    default=15,
                    help="the minimal quality of read mapping to take it in account")
parser.add_argument("--suffix",
                    default="cov",
                    help="the name of the suffix to use for the output file.")
parser.add_argument('-o', '--output',
                    dest='output_file',
                    help="the path of the output (default= base name of annotation file with --suffix)")
region_grp = parser.add_argument_group(title="region of interest",
                                       description="""Parameters which define regions to compute
There is 2 way to define regions:
    - all regions have same length
    - each region have different lengths
in both case  a position of reference must be define (--ref-col default = position)
if all regions have same length:
    --window define the number of nucleotide to take in account before and after the reference position
      (the window will be centered on reference)
    --before define the number of nucleotide to take in account after the reference position.
    --after define the number of nucleotide to take in account after the reference position.
    --before and --after allow to define non centered window.
--after and --before options must be set together and are incompatible with --window option.

If all regions have different lengths. The regions must be specified in the annotation file.
    --start-col define the name of the column in annotation file which define the start position of the region to compute.
    --stop-col define the name of the column in annotation file which define the stop position of the region to compute.
""")
region_grp.add_argument("--ref-col",
                        default="position",
                        help="the name of the column for the reference position.")
region_grp.add_argument("--before",
                        type=positive_int,
                        help="the number of base to compute after the position of reference.")
region_grp.add_argument("--after",
                        type=positive_int,
                        help="the number of base to compute before the position of reference.")
region_grp.add_argument("--window",
                        type=positive_int,
                        help="the number of base to compute around the position of reference.")
region_grp.add_argument("--start-col",
                        help="the name of the column to define the start position.")
region_grp.add_argument("--stop-col",
                        help="the name of the column to define the stop position.")
args = parser.parse_args()

group_one = (args.before, args.after, args.window)
group_two = (args.start_col, args.stop_col)
if all([v is None for v in itertools.chain(group_one, group_two)]):
    raise argparse.ArgumentError(None, "[--window or [--before, --after] or [--start-col, --stop-col] options"
                                 " must be specified")
elif any([v is not None for v in group_one]) and any([v is not None for v in group_two]):
    raise argparse.ArgumentError(None, "Options [--before, --after, --window] and [--start-col, --stop-col] "
                                 "are mutually exclusives.")
elif all([v is None for v in group_two]):
    if args.window is None:
        if any([v is None for v in (args.before, args.after)]):
            raise argparse.ArgumentError(None, "The two options --after and --before work together."
                                         " The both options must be specified in same time")
        else:
            pass
            # window is None, before and after are specify
            # => nothing to do
    else:
        # args.window is not None:
        if any([v is not None for v in (args.before, args.after)]):
            raise argparse.ArgumentError(None, "options [--before, --after] and --window are mutually exclusives.")
        else:
            # --before, --after are None
            args.before = args.after = args.window
elif not all(group_two):
    raise argparse.ArgumentError(None, "The two options --start-col and --stop-col work together. "
                                 "The both options must be specified in same time")

if not args.output_file:
    args.output_file = "{}.{}.txt".format(os.path.basename(os.path.splitext(args.annot_file)[0]), args.suffix)

annot_parser = annotation.AnnotationParser(args.annot_file, args.ref_col,
                                           strand_col='strand',
                                           start_col=args.start_col, stop_col=args.stop_col)

sam_file = pysam.AlignmentFile(args.bam_file, "rb")
annotations = annot_parser.get_annotations()

with open(args.output_file, 'w') as result_file:
    print("sense", *annot_parser.header, sep='\t', end='\t', file=result_file)
    max_left, max_right = annot_parser.max()
    if args.start_col:
        print(*list(range(0 - max_left, max_right + 1)), sep='\t', file=result_file)
    else:
        print(*list(range(0 - args.before, args.after + 1)), sep='\t', file=result_file)
    for annot_num, annot_entry in enumerate(annotations):
        if annot_num % 50 == 0:
            print('.', end='', file=sys.stderr)
            if annot_num % 2500 == 0:
                print('', file=sys.stderr)
            sys.stderr.flush()
        if args.start_col:
            start = annot_entry.start - 1
            stop = annot_entry.stop
        else:
            start = annot_entry.ref - args.before - 1
            stop = annot_entry.ref + args.after
        forward_cov, reverse_cov = coverage.get_coverage(sam_file,
                                                         annot_entry,
                                                         start=start, stop=stop,
                                                         qual_thr=args.qual_thr,
                                                         max_left=max_left, max_right=max_right)
        sens = 'S' if annot_entry.strand == '+' else 'AS'
        print(sens, annot_entry, *forward_cov, sep='\t', file=result_file)
        sens = 'S' if annot_entry.strand == '-' else 'AS'
        print(sens, annot_entry, *reverse_cov, sep='\t', file=result_file)
    print()
